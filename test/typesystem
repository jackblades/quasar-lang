RECORDS
    - patterns are ROW types, not structural whatever
    - functions like 'find, insert, etc' should go into the record
    - functions like 'copy a b' should be outside (possibly multimethods?)

shared typdef
opaque typedef

INTERFACES
    interface Closeable
        close () :: ...

    f = \c : Sock { Closeable, Copyable, Printable, open () :: .., :rest } ->
        c.copy ()
        c.print ()
        c.close ()

    x = { close () = ... } implements Closeable, Printable, ...  -- default set; automatic conversion

    f x  -- no conversion necessary
    f (Sock { close () = ... } as { Closeable, Printable, ...})  -- explicitly allow the conversion

    -- this could be the way to structure large programs
    -- {} only matches the empty struct, disallow casts to/from (its basically 'java.lang.Object')




CAST
    cast :: c a -> a  -- c is a constructor
        - map  :: c b = \ 
            f :: (a -> b),
            x :: c a
        -> c (f $ cast x)

    cast x st dt = x :: dt if st >= dt  -- narrowing cast for records
        - f :: { a, b } -> { c }
        - f $ cast { a, b, c }  -- { c }
        - wrap f x = x `with` f (cast x)  -- { a, b, c } 


EFFECTS
    - we want effects to be separate, < io, state, ... > and have pure and impure effects
        - runSTM :: pure STM a -> [ io ] a 
    - we want a simple system that allows all code that can actually run in a valid way to actually run
    
        - C1 a1 | C2 a2 | ... | Ck ak [ | :rest ]
        - { a1 = A1,                                       { a1 :: A1,
            a2 = A2,                                         a2 :: A2,
            ...                                               ...
            ak = Ak }                                        ak :: Ak, 
                                                            [ :rest ] }

OPEN / CLOSE EXPRESSION
- Closed Sum             can only be generated by            multiple returns                       [ inference ]
- Closed product                                             { ... }                                [ inference ]
- Open Sum                                                   otherwise clause                       [ inference ]
    - or                        = (|+)                    :: sum -> sum -> sum
- Open Product                                               arg + { ... }                          [ inference ]
    - union                     = (+)                     :: any-set -> set -> set
    - difference                = (-) or (/)              :: set -> set -> set
    - intersection              = (*)                     :: set -> set -> 

LENS
    - x.a.b.c %~ f 
    - 

DATASTRUCTURES
- default: list :: List a, vector :: Vector a, hashmap :: HMap k v, treemap :: TMap k v
- how to create new ones
    - 

newtree :: tree = \a :: element -> Tree {
    __data = [ a ]

    insert :: tree = \x :: element -> 
        this.__data %++ x  -- lens for 'modify add'
}







